# Метод Горнера

_Прочитайте це іншими мовами:_
[_English_](README.md).

У математиці Метод Горнера (або схема Горнера) є алгоритмом для обчислення значення полінома(многочлена). 
З цим методом можливо обчислити поліном з лише `n` додавань та `n` множень. Тому потрібно 
зберігати `n` разів кількість бітів `x`.

Метод Горнера може бути оснований на такій ідентичності:

![правило Горнера](https://wikimedia.org/api/rest_v1/media/math/render/svg/2a576e42d875496f8b0f0dda5ebff7c2415532e4)

Цю ідентичність називають _правилом Горнера_.

Щоб обчислити праву частину ідентичності вище, для заданого `x`, ми починаємо ітерувати поліном зсередини на 
зовні, накопичуючи результат кожної ітерації. Після `n` ітерацій, де `n` є порядком полінома, накопичений 
результат дає нам значення полінома.

**Використовування поліномів:**

`4 * x^4 + 2 * x^3 + 3 * x^2 + x^1 + 3`, традиційний підхід для обчислення його при `x = 2` може бути представлений 
у вигляді масиву `[3, 1, 3, 2, 4]` та ітеруватися по ньому, зберігаючи кожне значення ітерації в аккумуляторі, 
як от `acc += pow(x=2, index) * array[index]`. У суті, кожна операція піднесення до степеню числа (`pow`) 
складається з `n-1` множень. Тому в цьому сценарії відбулось загалом `14` операцій, які складаються з `4` додавань, 
`5` множень та `5` операцій піднесення до степеню (ми припускаємо, що кожна степінь обчислюється повторним множенням).

Тепер, **використовуючи той самий сценарій, але з правилом Хорнера**, многочлен можна переписати 
як `x * (x * (x * (4 * x + 2) + 3) + 1) + 3`, і, представивши його як `[4, 2, 3, 1, 3]`, можна зберегти 
першу ітерацію як `acc = arr[0] * (x=2) + arr[1]`, а потім завершувати ітерації для `acc *= (x=2) + arr[index]`. 
В тому самому сценарії, але використовуючи правило Хорнера, відбулося загалом лише `10` операцій, складених 
лише з `4` додавань та `4` множень.

## Посилання

- [Метод Горнера на Wikipedia](https://uk.wikipedia.org/wiki/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0_%D0%93%D0%BE%D1%80%D0%BD%D0%B5%D1%80%D0%B0)
