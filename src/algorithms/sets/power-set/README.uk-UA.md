# Множина всіх підмножин

_Прочитайте це іншими мовами:_
[_English_](README.md).

Степінь множини `S` - це множина всіх підмножин `S`, включаючи порожній набір 
і саму множину `S`. Степінь множини `S` позначається як `P(S)`.

Наприклад, для `{x, y, z}`, підмножини наступні:

```text
{
  {}, // (також позначається порожньою множиною ∅ або нульовою множиною)
  {x},
  {y},
  {z},
  {x, y},
  {x, z},
  {y, z},
  {x, y, z}
}
```

![Множина всіх підмножин](https://www.mathsisfun.com/sets/images/power-set.svg)

Отже, ось як можна проілюструвати елементи степеня множини {x, y, z} впорядковані за включенням:

![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Hasse_diagram_of_powerset_of_3.svg)

**Кількість підмножин**

Якщо `S` - скінченна множина з `|S| = n` елементів, то кількість підмножин `S` 
дорівнює `|P(S)| = 2^n`. Цей факт, який є мотивацією для позначення `2^S`, 
можна продемонструвати просто наступним чином:

> Спочатку впорядкуємо елементи `S` будь-яким способом. Ми записуємо будь-яку підмножину `S` у
форматі `{γ1, γ2, ..., γn}`, де `γi , 1 ≤ i ≤ n`, може приймати значення
`0` або `1`. Якщо `γi = 1`, `i`-й елемент `S` знаходиться в підмножині;
інакше `i`-й елемент не входить до підмножини. Очевидно кількість
окремими підмножинами, які можна побудувати таким чином, є `2^n` як `γi ∈ {0, 1}`.

## Алгоритми

### Побітове рішення

Кожне число в двійковому представленні в діапазоні від `0` до `2^n` робить те, 
що нам потрібно: він показує своїми бітами (`0` або `1`), чи потрібно включати 
пов'язаний елемент з множини чи ні. Наприклад, для `{1, 2, 3}` бінарне 
число `0b010` означатиме, що нам потрібно включити лише `2` до поточного набору.

|       | `abc` | підмножина    |
| :---: | :---: | :-----------: |
| `0`   | `000` | `{}`          |
| `1`   | `001` | `{c}`         |
| `2`   | `010` | `{b}`         |
| `3`   | `011` | `{c, b}`      |
| `4`   | `100` | `{a}`         |
| `5`   | `101` | `{a, c}`      |
| `6`   | `110` | `{a, b}`      |
| `7`   | `111` | `{a, b, c}`   |

> Перегляньте [bwPowerSet.js](./bwPowerSet.js) файл для побітового рішення.

### Рішення зворотного відстеження

Під час використання методу зворотного відстеження ми постійно намагаємось додати 
наступний елемент множини до підмножини, запам'ятовуючи його, а потім видаляємо і 
спробуємо зробити те саме з наступним елементом.

> Перегляньте [btPowerSet.js](./btPowerSet.js) файл для рішення зворотного відстеження.

### Каскадне рішення

Це, мабуть, найпростіший спосіб згенерувати потужний набір.

Ми починаємо з порожнього набору:

```text
powerSets = [[]]
```

Тепер, скажімо:

```text
originalSet = [1, 2, 3]
```

Додамо 1-й елемент з `originalSet` до всіх існуючих наборів:

```text
[[]] ← 1 = [[], [1]]
```

Додавання 2-го елемента до всіх існуючих наборів:

```text
[[], [1]] ← 2 = [[], [1], [2], [1, 2]]
```

Додавання 3-го елемента до всіх існуючих наборів:

```
[[], [1], [2], [1, 2]] ← 3 = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
```

І так далі, для решти елементів з `originalSet`. На кожній ітерації кількість наборів подвоюється, отже ми отримаємо `2^n` наборів.

> Перегляньте [caPowerSet.js](./caPowerSet.js) файл для каскадного рішення.

## Посилання

* [Wikipedia](https://uk.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B0%D0%BD)
* [Math is Fun](https://www.mathsisfun.com/sets/power-set.html)
